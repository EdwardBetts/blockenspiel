<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>Blockenspiel - Blockenspiel 0.5.0 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Blockenspiel">Blockenspiel</a>
    <li><a href="#label-What-27s+a+DSL+block-3F">What&#39;s a DSL block?</a>
    <li><a href="#label-How+does+one+implement+such+a+beast-3F">How does one implement such a beast?</a>
    <li><a href="#label-So+what+is+Blockenspiel-3F">So what <em>is</em> Blockenspiel?</a>
    <li><a href="#label-How+does+that+help+me-3F+-28Or-2C+why+not+just+use+instance_eval-3F-29">How does that help me? (Or, why not just use instance_eval?)</a>
    <li><a href="#label-Is+that+it-3F">Is that it?</a>
    <li><a href="#label-Requirements">Requirements</a>
    <li><a href="#label-Installation">Installation</a>
    <li><a href="#label-Known+issues+and+to-do+items">Known issues and to-do items</a>
    <li><a href="#label-Development+and+support">Development and support</a>
    <li><a href="#label-Author+-2F+Credits">Author / Credits</a>
    <li><a href="#label-License">License</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./Blockenspiel_rdoc.html">Blockenspiel</a>
  
    <li><a href="./History_rdoc.html">History</a>
  
    <li><a href="./ImplementingDSLblocks_rdoc.html">ImplementingDSLblocks</a>
  
    <li><a href="./README_rdoc.html">README</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page Blockenspiel.rdoc">

<h2 id="label-Blockenspiel"><a href="Blockenspiel.html">Blockenspiel</a><span><a href="#label-Blockenspiel">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="Blockenspiel.html">Blockenspiel</a> is a helper library designed
to make it easy to implement DSL blocks. It is designed to be comprehensive
and robust, supporting most common usage patterns, and working correctly in
the presence of nested blocks and multithreading.</p>

<p>This is an introduction to DSL blocks and the features of <a
href="Blockenspiel.html">Blockenspiel</a>.</p>

<h3 id="label-What-27s+a+DSL+block-3F">What&#39;s a DSL block?<span><a href="#label-What-27s+a+DSL+block-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A DSL block is an API pattern in which a method call takes a block that can
provide further configuration for the call. A classic example is the <a
href="http://www.rubyonrails.org/">Rails</a> route definition:</p>

<pre class="ruby"><span class="ruby-constant">ActionController</span><span class="ruby-operator">::</span><span class="ruby-constant">Routing</span><span class="ruby-operator">::</span><span class="ruby-constant">Routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">map</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">map</span>.<span class="ruby-identifier">connect</span> <span class="ruby-string">&#39;:controller/:action/:id&#39;</span>
  <span class="ruby-identifier">map</span>.<span class="ruby-identifier">connect</span> <span class="ruby-string">&#39;:controller/:action/:id.:format&#39;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Some libraries go one step further and eliminate the need for a block
parameter. <a href="http://rspec.info/">RSpec</a> is a well-known example:</p>

<pre class="ruby"><span class="ruby-identifier">describe</span> <span class="ruby-constant">Stack</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">before</span>(:<span class="ruby-identifier">each</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-ivar">@stack</span> = <span class="ruby-constant">Stack</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">describe</span> <span class="ruby-string">&quot;(empty)&quot;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">it</span> { <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">should</span> <span class="ruby-identifier">be_empty</span> }
    <span class="ruby-identifier">it</span> <span class="ruby-node">&quot;should complain when sent #peek&quot;</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">lambda</span> { <span class="ruby-ivar">@stack</span>.<span class="ruby-identifier">peek</span> }.<span class="ruby-identifier">should</span> <span class="ruby-identifier">raise_error</span>(<span class="ruby-constant">StackUnderflowError</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In both cases, the caller provides descriptive information in the block,
using a domain-specific language. The second form, which eliminates the
block parameter, often appears cleaner; however it is also sometimes less
clear what is actually going on.</p>

<h3 id="label-How+does+one+implement+such+a+beast-3F">How does one implement such a beast?<span><a href="#label-How+does+one+implement+such+a+beast-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Implementing the first form is fairly straightforward. You would create a
class defining the methods (such as <code>connect</code> in our Rails
routing example above) that should be available within the block. When, for
example, the <code>draw</code> method is called with a block, you
instantiate the class and yield it to the block.</p>

<p>The second form is perhaps more mystifying. Somehow you would need to make
the DSL methods available on the “self” object inside the block. There are
several plausible ways to do this, such as using
<code>instance_eval</code>. However, there are many subtle pitfalls in such
techniques, and quite a bit of discussion has taken place in the Ruby
community regarding how–or whether–to safely implement such a syntax.</p>

<p>I have included a critical survey of the discussion in the document <a
href="ImplementingDSLblocks_rdoc.html">ImplementingDSLblocks.rdoc</a> for
the curious. <a href="Blockenspiel.html">Blockenspiel</a> takes what I
consider the best of the solutions and implements them in a comprehensive
way, shielding you from the complexity of the Ruby metaprogramming while
offering a simple way to implement both forms of DSL blocks.</p>

<h3 id="label-So+what+is+Blockenspiel-3F">So what <em>is</em> <a href="Blockenspiel.html">Blockenspiel</a>?<span><a href="#label-So+what+is+Blockenspiel-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Blockenspiel.html">Blockenspiel</a> operates on the following
observations:</p>
<ul><li>
<p>Implementing a DSL block that takes a parameter is straightforward.</p>
</li><li>
<p>Safely implementing a DSL block that <em>doesn&#39;t</em> take a parameter
is tricky.</p>
</li></ul>

<p>With that in mind, <a href="Blockenspiel.html">Blockenspiel</a> provides a
set of tools that allow you to take an implementation of the first form of
a DSL block, one that takes a parameter, and turn it into an implementation
of the second form, one that doesn&#39;t take a parameter.</p>

<p>Suppose you wanted to write a simple DSL block that takes a parameter:</p>

<pre class="ruby"><span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">config</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">config</span>.<span class="ruby-identifier">add_foo</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">config</span>.<span class="ruby-identifier">add_bar</span>(<span class="ruby-value">2</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>You could write this as follows:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ConfigMethods</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_foo</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-comment"># do something</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_bar</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-comment"># do something</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">configure_me</span>
  <span class="ruby-keyword">yield</span> <span class="ruby-constant">ConfigMethods</span>.<span class="ruby-identifier">new</span>
<span class="ruby-keyword">end</span>
</pre>

<p>That was easy. However, now suppose you wanted to support usage
<em>without</em> the “config” parameter. e.g.</p>

<pre class="ruby"><span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_foo</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">add_bar</span>(<span class="ruby-value">2</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>With <a href="Blockenspiel.html">Blockenspiel</a>, you can do this in two
quick steps. First, tell <a href="Blockenspiel.html">Blockenspiel</a> that
your <code>ConfigMethods</code> class is a DSL.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ConfigMethods</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Blockenspiel</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>   <span class="ruby-comment"># &lt;--- Add this line</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_foo</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-comment"># do something</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_bar</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-comment"># do something</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Next, write your <code>configure_me</code> method using Blockenspiel:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">configure_me</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-constant">Blockenspiel</span>.<span class="ruby-identifier">invoke</span>(<span class="ruby-identifier">block</span>, <span class="ruby-constant">ConfigMethods</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Now, your <code>configure_me</code> method supports <em>both</em> DSL block
forms. A caller can opt to use the first form, with a parameter, simply by
providing a block that takes a parameter. Or, if the caller provides a
block that doesn&#39;t take a parameter, the second form without a
parameter is used.</p>

<h3 id="label-How+does+that+help+me-3F+-28Or-2C+why+not+just+use+instance_eval-3F-29">How does that help me? (Or, why not just use instance_eval?)<span><a href="#label-How+does+that+help+me-3F+-28Or-2C+why+not+just+use+instance_eval-3F-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>As noted earlier, some libraries that provide parameter-less DSL blocks use
a simple <code>instance_eval</code>, and they could even support both the
parameter and parameter-less mechanisms by checking the block arity:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">configure_me</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">arity</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-constant">ConfigMethods</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">ConfigMethods</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">instance_eval</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>That seems like a simple and effective technique that doesn&#39;t require a
separate library, so why use <a href="Blockenspiel.html">Blockenspiel</a>?
Because <code>instance_eval</code> introduces a number of surprising
problems. I discuss these issues in detail in <a
href="ImplementingDSLblocks_rdoc.html">ImplementingDSLblocks.rdoc</a>, but
just to get your feet wet, suppose the caller wanted to call its own
methods inside the block:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">callers_helper_method</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_foo</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">callers_helper_method</span>  <span class="ruby-comment"># Error! self is now an instance of ConfigMethods</span>
                         <span class="ruby-comment"># so this will fail with a NameError</span>
  <span class="ruby-identifier">add_bar</span>(<span class="ruby-value">2</span>)
<span class="ruby-keyword">end</span>
</pre>

<p><a href="Blockenspiel.html">Blockenspiel</a> employs a number of techniques
to mitigate the ill effects of <code>instance_eval</code>. It delegates
methods that are not part of the DSL, back to the enclosing context object,
so that the caller retains access to helper methods. It also includes an
optional experimental technique (not available on all ruby platforms) that
temporarily mixes the DSL methods directly into the caller&#39;s
<code>self</code> object, so that instance variable access is retained.</p>

<h3 id="label-Is+that+it-3F">Is that it?<span><a href="#label-Is+that+it-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Although the basic usage is very simple, <a
href="Blockenspiel.html">Blockenspiel</a> is designed to be
<em>comprehensive</em>. It supports all the use cases that I&#39;ve run
into during my own implementation of DSL blocks. Notably:</p>

<p>By default, <a href="Blockenspiel.html">Blockenspiel</a> lets the caller
choose to use a parametered block or a parameterless block, based on
whether or not the block actually takes a parameter. You can also disable
one or the other, to force the use of either a parametered or parameterless
block.</p>

<p>You can also let the caller use your DSL by passing you a string or a file
rather than a block. That is, you can create file-based DSLs such as the
Rails routes file.</p>

<p>You can control wich methods of the class are available from parameterless
blocks, and/or make some methods available under different names. Here are
a few examples:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ConfigMethods</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Blockenspiel</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_foo</span>         <span class="ruby-comment"># automatically added to the dsl</span>
    <span class="ruby-comment"># do stuff...</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">my_private_method</span>
    <span class="ruby-comment"># do stuff...</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">dsl_method</span> :<span class="ruby-identifier">my_private_method</span>, <span class="ruby-keyword">false</span>   <span class="ruby-comment"># remove from the dsl</span>

  <span class="ruby-identifier">dsl_methods</span> <span class="ruby-keyword">false</span>   <span class="ruby-comment"># stop automatically adding methods to the dsl</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">another_private_method</span>  <span class="ruby-comment"># not added</span>
    <span class="ruby-comment"># do stuff...</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">dsl_methods</span> <span class="ruby-keyword">true</span>    <span class="ruby-comment"># resume automatically adding methods to the dsl</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_bar</span>         <span class="ruby-comment"># this method is automatically added</span>
    <span class="ruby-comment"># do stuff...</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">add_baz</span>
    <span class="ruby-comment"># do stuff</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">dsl_method</span> :<span class="ruby-identifier">add_baz_in_dsl</span>, :<span class="ruby-identifier">add_baz</span>  <span class="ruby-comment"># Method named differently</span>
                                        <span class="ruby-comment"># in a parameterless block</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This is also useful, for example, when you use <code>attr_writer</code>.
Parameterless blocks do not support <code>attr_writer</code> (or, by
corollary, <code>attr_accessor</code>) well because methods with names of
the form “attribute=” are syntactically indistinguishable from variable
assignments:</p>

<pre class="ruby"><span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">config</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">config</span>.<span class="ruby-identifier">foo</span> = <span class="ruby-value">1</span>    <span class="ruby-comment"># works fine when the block has a parameter</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># foo = 1     # &lt;--- Doesn&#39;t work: looks like a variable assignment</span>
  <span class="ruby-identifier">set_foo</span>(<span class="ruby-value">1</span>)    <span class="ruby-comment"># &lt;--- Fix it by renaming to this instead</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is implemented like this::</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">ConfigMethods</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Blockenspiel</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>
  <span class="ruby-identifier">attr_writer</span> :<span class="ruby-identifier">foo</span>
  <span class="ruby-identifier">dsl_method</span> :<span class="ruby-identifier">set_foo</span>, :<span class="ruby-identifier">foo=</span>    <span class="ruby-comment"># Make &quot;foo=&quot; available as &quot;set_foo&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This is in fact a common enough case that <a
href="Blockenspiel.html">Blockenspiel</a> includes conveninence tools for a
DSL-friendly attr_writer and attr_accessor, providing an alternate syntax
for setting attributes within a parameterless block:</p>

<pre class="ruby"><span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># foo = 1             # This syntax wouldn&#39;t work, but</span>
  <span class="ruby-identifier">foo</span> <span class="ruby-value">1</span>                 <span class="ruby-comment"># this syntax is now supported.</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;foo is #{foo}&quot;</span>  <span class="ruby-comment"># The getter still works.</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is implemented like this::</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">ConfigMethods</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Blockenspiel</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>
  <span class="ruby-identifier">dsl_attr_accessor</span> :<span class="ruby-identifier">foo</span>     <span class="ruby-comment"># DSL-friendly attr_accessor</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In some cases, you might want to dynamically generate a DSL object rather
than defining a static class. <a href="Blockenspiel.html">Blockenspiel</a>
provides a tool to do just that. Here&#39;s an example:</p>

<pre class="ruby"><span class="ruby-constant">Blockenspiel</span>.<span class="ruby-identifier">invoke</span>(<span class="ruby-identifier">block</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_method</span>(:<span class="ruby-identifier">set_foo</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">my_foo</span> = <span class="ruby-identifier">value</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">add_method</span>(:<span class="ruby-identifier">set_things_using_block</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">blk</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">my_foo</span> = <span class="ruby-identifier">value</span>
    <span class="ruby-identifier">my_bar</span> = <span class="ruby-identifier">blk</span>.<span class="ruby-identifier">call</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>That API is itself a DSL block, and yes, <a
href="Blockenspiel.html">Blockenspiel</a> uses itself to implement this
feature.</p>

<p>By default <a href="Blockenspiel.html">Blockenspiel</a> uses mixins, which
usually exhibit fairly safe and non-surprising behavior. However, there are
a few cases when you might want the <code>instance_eval</code> behavior
anyway. RSpec is a good example of such a case, since the DSL is being used
to construct objects, so it makes sense for instance variables inside the
block to belong to the object being constructed. <a
href="Blockenspiel.html">Blockenspiel</a> gives you the option of choosing
<code>instance_eval</code> in case you need it. <a
href="Blockenspiel.html">Blockenspiel</a> also provides a compromise
behavior that uses a proxy to dispatch methods to the DSL object or the
block&#39;s context.</p>

<p><a href="Blockenspiel.html">Blockenspiel</a> also correctly handles nested
blocks. e.g.</p>

<pre class="ruby"><span class="ruby-identifier">configure_me</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">set_foo</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">configure_another</span> <span class="ruby-keyword">do</span>     <span class="ruby-comment"># A block within another block</span>
    <span class="ruby-identifier">set_bar</span>(<span class="ruby-value">2</span>)
    <span class="ruby-identifier">configure_another</span> <span class="ruby-keyword">do</span>   <span class="ruby-comment"># A block within itself</span>
      <span class="ruby-identifier">set_bar</span>(<span class="ruby-value">3</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p><a href="Blockenspiel.html">Blockenspiel</a> provides three strategies for
doing parameterless DSL blocks.</p>

<p>The default strategy uses a proxy object that delegates unrecognized
methods out to the calling context. It should work well for most cases.</p>

<p>Second, some applications might want to use the simple
<code>instance_eval</code> behavior. RSpec is a good example of such a
case, since the DSL is being used to construct objects, so it makes sense
for instance variables inside the block to belong to the object being
constructed.</p>

<p>Third, an experimental mixin strategy is provided, which adds the DSL
methods directly to the context&#39;s self object, and removes them
afterward. This is available on Rubinius and JRuby but not on MRI.</p>

<p>Finally, <a href="Blockenspiel.html">Blockenspiel</a> is thread safe,
correctly handling, for example, the case of multiple threads trying to mix
methods into the same object concurrently.</p>

<h3 id="label-Requirements">Requirements<span><a href="#label-Requirements">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p>Ruby 1.9.3 or later, JRuby 1.5 or later, or Rubinius 1.0 or later.</p>
</li></ul>

<h3 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">blockenspiel</span>
</pre>

<h3 id="label-Known+issues+and+to-do+items">Known issues and to-do items<span><a href="#label-Known+issues+and+to-do+items">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p>Implementing wildcard DSL methods using <code>method_missing</code>
doesn&#39;t work. I haven&#39;t yet decided on the right semantics for this
case, or whether it is even a reasonable feature at all.</p>
</li><li>
<p>Including <a href="Blockenspiel/DSL.html">Blockenspiel::DSL</a> in a module
(rather than a class) is not yet supported, but this is planned for a
future release.</p>
</li><li>
<p>Find a way to implement mixin behavior reliably on MRI.</p>
</li></ul>

<h3 id="label-Development+and+support">Development and support<span><a href="#label-Development+and+support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Documentation is available at <a
href="http://dazuma.github.com/blockenspiel/rdoc">dazuma.github.com/blockenspiel/rdoc</a></p>

<p>Source code is hosted on Github at <a
href="http://github.com/dazuma/blockenspiel">github.com/dazuma/blockenspiel</a></p>

<p>Contributions are welcome. Fork the project on Github.</p>

<p>Build status: <a href="http://travis-ci.org/dazuma/blockenspiel"><img
src="https://secure.travis-ci.org/dazuma/blockenspiel.png" /></a></p>

<p>Report bugs on Github issues at <a
href="http://github.org/dazuma/blockenspiel/issues">github.org/dazuma/blockenspiel/issues</a></p>

<p>Contact the author at dazuma at gmail dot com.</p>

<h3 id="label-Author+-2F+Credits">Author / Credits<span><a href="#label-Author+-2F+Credits">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Blockenspiel.html">Blockenspiel</a> is written by Daniel Azuma (<a
href="http://www.daniel-azuma.com">www.daniel-azuma.com</a>/).</p>

<p>The mixin implementation is based on a concept by the late Why The Lucky
Stiff, documented in his 6 October 2008 blog posting entitled “Mixing Our
Way Out Of Instance Eval?”. The original link is gone, but you may find
copies or mirrors out there.</p>

<p>The unmixer code is based on <a
href="http://rubyforge.org/projects/mixology">Mixology</a>, version by
Patrick Farley, anonymous z, Dan Manges, and Clint Bishop. The JRuby code
is adapted from Mixology 0.1, and has been stripped down and modified to
support JRuby &gt;= 1.2. The Rubinius code was adapted from unreleased code
in the Mixology source tree and modified to support Rubinius 1.0. I know
Mixology 0.2 is now available, but its Rubinius support is not active, and
I&#39;d rather keep the unmixer bundled with <a
href="Blockenspiel.html">Blockenspiel</a> for now to reduce dependencies.
Earlier versions of <a href="Blockenspiel.html">Blockenspiel</a> also
included a C extension, adapted from Mixology, to support mixins for MRI,
but this code has been disabled due to issues with newer versions of Ruby.</p>

<p>The dsl_attr_writer and dsl_attr_accessor feature came from a suggestion by
Luis Lavena.</p>

<h3 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Copyright 2008 Daniel Azuma.</p>

<p>All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ul><li>
<p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li><li>
<p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li><li>
<p>Neither the name of the copyright holder, nor the names of any other
contributors to this software, may be used to endorse or promote products
derived from this software without specific prior written permission.</p>
</li></ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

